# modules/cli.py

"""
This module centralizes all command‑line interactions.
It includes:
  • Interactive pause logic (prompt, timer with countdown, off).
  • Typer‑based CLI parsing.
  • Global exception and signal handling.
  • Commands to clear various stored data.
"""

import sys
import time
# import signal # Signal handling is effectively done via KeyboardInterrupt in the hook
import shutil
import traceback
from pathlib import Path
from typing import Optional
import typer
import select
import os
from modules.logs import logger
from modules.config import config # Assuming config is loaded elsewhere and accessible

# --- Platform specific setup ---
try:
    import msvcrt
    WINDOWS = True
except ImportError:
    WINDOWS = False
    import termios
    import tty

# --- Global State ---
# Use '.' as default SCRIPT_DIR if not set in config, resolve to absolute path
SCRIPT_DIR = Path(config.get("SCRIPT_DIR", ".")).resolve()
_skip_prompts = False

# Centralized data paths: Use config value or default to {SCRIPT_DIR}/data
# Use pathlib's division operator for joining paths
DATA_DIR = Path(config.get("DATA_DIR", SCRIPT_DIR / "data")).resolve()
REPOS_DIR = DATA_DIR / "repos"
LOGS_DIR = DATA_DIR / "logs"
THOUGHTS_DIR = DATA_DIR / "thoughts"
REQUESTS_DIR = DATA_DIR / "requests"
STATE_DIR = DATA_DIR / "state" # Added state dir path consistently

# Ensure data directories exist (optional, but can be helpful)
# Consider moving this to an initialization function if needed elsewhere
# DATA_DIR.mkdir(parents=True, exist_ok=True)
# REPOS_DIR.mkdir(exist_ok=True)
# LOGS_DIR.mkdir(exist_ok=True)
# THOUGHTS_DIR.mkdir(exist_ok=True)
# REQUESTS_DIR.mkdir(exist_ok=True)
# STATE_DIR.mkdir(exist_ok=True)


# --- Terminal Interaction Functions ---

def _getch():
    """
    Captures a single blocking key press. Restores terminal settings on exit.
    """
    if WINDOWS:
        # Read a single byte and decode it
        return msvcrt.getch().decode("utf-8", errors="ignore")
    else:
        # Unix-like systems
        fd = sys.stdin.fileno()
        # Check if stdin is a TTY
        if not os.isatty(fd):
             logger.warning("Standard input is not a TTY. Cannot get single character.")
             # Decide fallback behavior: maybe read a line? Or raise error?
             # For now, return None or empty string as a signal
             return "" # Or perhaps None

        old_settings = termios.tcgetattr(fd)
        try:
            # Use tty.setraw for simplest single char read.
            # Reads character immediately without echo or processing.
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            # Ensure terminal settings are restored
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


def _getch_nonblocking():
    """
    Attempts to capture a single key press without blocking.
    Assumes the caller handles terminal mode setting if necessary (Unix).
    Returns the key if available; otherwise, returns None.
    """
    if WINDOWS:
        if msvcrt.kbhit():
            return msvcrt.getch().decode("utf-8", errors="ignore")
        return None
    else:
        # Unix-like systems
        # Assumes terminal is already in cbreak or raw mode by the caller
        # Use select to check if input is available without blocking
        dr, _, _ = select.select([sys.stdin], [], [], 0)
        if dr:
            # Check if it's actually stdin that's ready (it should be)
            if sys.stdin in dr:
                try:
                    # Read exactly one character
                    return sys.stdin.read(1)
                except Exception as e:
                    # Log error during read - this shouldn't normally happen
                    logger.debug(f"Error reading from stdin after select: {e}")
                    return None
        return None


def _interruptible_countdown(total_seconds: float):
    """
    Performs an interruptible countdown.

    During the countdown:
      - Pressing 'q' quits the program.
      - Pressing 'p' toggles pause/resume of the countdown.
      - Pressing 's' cancels the prompt for all subsequent turns.
      - Pressing any other key immediately stops the countdown for this turn.

    Handles terminal mode setting on Unix-like systems (uses cbreak mode).
    """
    global _skip_prompts
    remaining = float(total_seconds) # Ensure float arithmetic
    paused = False
    interval = 0.1  # Check interval in seconds

    fd = None
    old_settings = None
    set_mode_success = False

    # --- Setup Terminal Mode (Unix) ---
    # Only change mode if stdin is a TTY
    if not WINDOWS and sys.stdin.isatty():
        fd = sys.stdin.fileno()
        try:
            old_settings = termios.tcgetattr(fd)
            # Use cbreak: reads chars immediately, passes signals (like Ctrl+C)
            # This allows the KeyboardInterrupt handler to catch Ctrl+C.
            tty.setcbreak(fd)
            set_mode_success = True
            logger.debug("Terminal set to cbreak mode for countdown.")
        except termios.error as e:
            logger.warning(f"Could not set terminal to cbreak mode: {e}. Key interrupts during timer may not work.")
        except Exception as e:
            logger.warning(f"Unexpected error setting terminal mode: {e}. Key interrupts during timer may not work.")

    # --- Countdown Loop ---
    try:
        start_time = time.monotonic() # Use monotonic clock for reliable intervals
        pause_start_time = None
        prompt_line_len = 0 # Track length of printed line for proper clearing

        while remaining > 0:
            current_time = time.monotonic()

            # --- Handle Pause State ---
            if paused:
                if pause_start_time is None:
                    pause_start_time = current_time # Record when pause started
                # Don't decrement remaining time while paused

                status_msg = "Countdown paused. Press 'p' to resume, 'q' to quit, 's' to skip all, any other to skip now..."
                # Ensure the status message overwrites the previous one completely
                print(f"{status_msg:<{prompt_line_len}}", end="\r", flush=True)
                prompt_line_len = max(prompt_line_len, len(status_msg)) # Update max length seen

            # --- Handle Running State ---
            else:
                if pause_start_time is not None:
                    # Resuming: Adjust start time to account for pause duration
                    pause_duration = current_time - pause_start_time
                    start_time += pause_duration
                    pause_start_time = None # Reset pause timer

                # Calculate remaining time based on elapsed monotonic time
                elapsed_time = current_time - start_time
                remaining = total_seconds - elapsed_time

                if remaining <= 0:
                    break # Time's up

                # Display remaining seconds (ceiling)
                status_msg = f"Resuming in {int(remaining)+1} seconds... (p=pause, q=quit, s=skip all, other=skip now)"
                print(f"{status_msg:<{prompt_line_len}}", end="\r", flush=True)
                prompt_line_len = max(prompt_line_len, len(status_msg))

            # --- Check for User Input ---
            # _getch_nonblocking assumes terminal mode is already set (cbreak/raw)
            key = _getch_nonblocking()

            if key is not None:
                key_lower = key.lower()

                # --- Clear the current status line BEFORE acting ---
                print(" " * prompt_line_len, end="\r", flush=True)

                if key_lower == 'q':
                    logger.info("Exiting during countdown as 'q' was pressed.")
                    # Terminal restoration happens in finally block
                    sys.exit(0) # Exit cleanly

                elif key_lower == 'p':
                    paused = not paused
                    # Loop will print the new status in the next iteration
                    continue # Go to next loop iteration immediately

                elif key_lower == 's':
                    _skip_prompts = True
                    print("Prompt cancelled for all subsequent turns.", flush=True) # Print confirmation on new line
                    return # Exit countdown function, proceed immediately

                else:
                    # Any other key skips the *current* countdown
                    print("Countdown interrupted, skipping wait.", flush=True) # Print confirmation on new line
                    return # Exit countdown function, proceed immediately

            # --- Sleep ---
            # Sleep only if not paused to avoid busy-waiting while paused
            if not paused:
                # Sleep for the interval or remaining time, whichever is smaller
                sleep_duration = min(interval, remaining) if remaining > 0 else interval
                time.sleep(sleep_duration)
            else:
                # While paused, sleep a bit longer to reduce CPU usage
                time.sleep(interval) # Still check for key presses regularly

        # --- Countdown Finished Naturally ---
        # Clear the final status line before printing completion message
        print(" " * prompt_line_len, end="\r", flush=True)
        print("Resuming now.", flush=True) # Indicate completion on new line

    finally:
        # --- Restore Terminal Mode (Unix) ---
        # This block executes even if sys.exit() was called or return occurred
        if set_mode_success and fd is not None and old_settings is not None:
            try:
                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                logger.debug("Terminal settings restored.")
            except Exception as e:
                 logger.error(f"Failed to restore terminal settings: {e}")
        # Ensure the cursor is definitely on a new line if the countdown finished or was interrupted
        # print() # Seems unnecessary now confirmations print with newline


# --- Banner, Exception Handling, Interactive Pause ---

def banner():
    """
    Prints a multi‑line banner. Uses raw string to avoid escape sequence warnings.
    """
    # Use raw string literal r"""..."""
    banner_text = r"""
 ____        _       _
/ ___|  ___ | |_   _(_)_ __
\___ \ / _ \| \ \ / / | '_ \
 ___) | (_) | |\ V /| | | | |
|____/ \___/|_| \_/ |_|_| |_|
"""
    print(banner_text)

def handle_exception(exc_type, exc_value, exc_traceback):
    """
    Global exception handler. Logs errors and handles graceful exit.
    Ensures terminal settings are restored via finally blocks elsewhere.
    """
    # Attempt to restore terminal state if possible (best effort in handler)
    # The finally block in _interruptible_countdown is the primary restoration point
    if not WINDOWS and sys.stdin.isatty():
         try:
             # This assumes 'tty' and 'termios' are available and we know the original state
             # which is hard. Rely on the try/finally blocks in functions using tty.
             # For safety, we could try to fetch current settings and reset to a known safe default
             # but it's complex. Best to rely on structured finally blocks.
             pass # Rely on finally blocks in functions like _interruptible_countdown
         except Exception:
             pass # Ignore errors during emergency reset attempt

    if isinstance(exc_value, KeyboardInterrupt):
        print("\nExecution interrupted by the user (Ctrl+C). Exiting gracefully.", file=sys.stderr)
        sys.exit(0) # Clean exit code for Ctrl+C
    elif isinstance(exc_value, SystemExit):
        # Allow sys.exit() calls (e.g., from 'q' press, Typer exits) to propagate
        raise exc_value # Re-raise to exit with the intended code
    else:
        # Log the full traceback for unexpected errors
        stack_trace = "".join(traceback.format_exception(exc_type, exc_value, exc_traceback))
        logger.error("Unhandled exception occurred:\n%s", stack_trace)
        # Print a user-friendly message to stderr
        print("\nAn unexpected error occurred. Please check the log file for details.", file=sys.stderr)
        sys.exit(1) # Exit with a non-zero code to indicate failure

# Register the global exception hook
sys.excepthook = handle_exception

# Signal handling for SIGINT (Ctrl+C) is effectively managed by
# catching KeyboardInterrupt in the excepthook. No separate signal handler needed.
# signal.signal(signal.SIGINT, lambda sig, frame: sys.exit(0)) # This would be redundant

def interactive_pause(turn_counter: int):
    """
    Pauses execution between turns based on the INTERACTIVE_MODE setting.

    INTERACTIVE_MODE settings from config:
      - "prompt": Waits for a key press (q=quit, s=skip all, p=timer, other=continue).
      - "timer": Uses an interruptible timer countdown.
      - "off":   Proceeds immediately without pausing.
    """
    global _skip_prompts
    if _skip_prompts:
        logger.debug(f"Turn {turn_counter}: Skipping prompt.")
        return

    mode = config.get("INTERACTIVE_MODE", "prompt").strip().lower()
    sleep_time = float(config.get("INTERACTIVE_TIMER_SECONDS", 3.0)) # Ensure float

    if mode == "timer":
        logger.debug(f"Turn {turn_counter}: Starting {sleep_time}s timer pause.")
        try:
            _interruptible_countdown(sleep_time)
        except Exception as e:
            # Log error but continue execution
            logger.error(f"Error during timer countdown: {e}", exc_info=False) # Don't log full trace here, just message
            print("\nError during timer, continuing automatically...", file=sys.stderr)
            time.sleep(0.5) # Brief pause after error

    elif mode == "prompt" or mode != "off": # Default to "prompt" if invalid mode or "prompt" is set
        logger.debug(f"Turn {turn_counter}: Waiting for user prompt.")
        try:
            # Use a temporary print without newline for the prompt itself
            prompt_msg = f"Turn {turn_counter}: Press any key to continue (q=quit, s=skip all prompts, p=start {sleep_time}s timer): "
            print(prompt_msg, end="", flush=True)

            # Use the blocking _getch here. Needs TTY.
            user_in = _getch()
            print() # Move to the next line after key press received or function returns

            if not user_in: # Handle case where _getch couldn't read (e.g., not a TTY)
                logger.warning("Could not read from TTY in prompt mode. Continuing automatically.")
                time.sleep(0.5)
                return

            user_in_lower = user_in.lower()

            if user_in_lower == "q":
                logger.info(f"Exiting at turn {turn_counter} per user request ('q' pressed).")
                sys.exit(0)
            elif user_in_lower == "s":
                _skip_prompts = True
                print("Prompts skipped for all subsequent turns. Continuing...")
                logger.info("Prompts skipped via 's' key.")
                return # Continue to next turn immediately
            elif user_in_lower == "p":
                print(f"Starting {sleep_time} second timer pause (interruptible)...")
                logger.debug(f"User pressed 'p', starting timer pause.")
                try:
                    _interruptible_countdown(sleep_time)
                except Exception as e:
                    logger.error(f"Error during timer countdown triggered by 'p': {e}", exc_info=False)
                    print("\nError during timer, continuing automatically...", file=sys.stderr)
                    time.sleep(0.5) # Brief pause after error
            else:
                # Any other key: Just continue immediately
                logger.debug(f"User pressed '{user_in}', continuing.")
                return # Function ends, execution continues

        except KeyboardInterrupt:
            # This should now be caught by the sys.excepthook
            # No need for specific handling here, the hook will manage exit.
            pass
        except Exception as e:
            logger.error(f"Error during prompt mode: {e}", exc_info=False)
            # Fallback: maybe just wait a bit? Or continue?
            print(f"\nError during prompt ({e}), continuing automatically...", file=sys.stderr)
            time.sleep(1) # Brief pause

    elif mode == "off":
        logger.debug(f"Turn {turn_counter}: Interactive mode off, proceeding.")
        # Do nothing and return immediately

# --- Typer CLI Application ---

# Callback function placeholder - to be set by the main script
_run_callback = None

def register_run_callback(callback):
    """
    Registers a callback to be invoked for running the conversation pipeline.

    The callback should accept keyword arguments matching the options
    passed from the CLI main function (e.g., repo, config_file, debug).
    Example signature: callback(**kwargs) or callback(repo: str, config_file: str, debug: bool)
    """
    global _run_callback
    _run_callback = callback

# Main Typer application instance
app = typer.Typer(
    help="Agentic Swarm CLI - Run code generation pipelines.",
    no_args_is_help=True, # Show help if no command/required args are given
    add_completion=False # Disable shell completion commands if not needed
)

@app.callback(invoke_without_command=True)
def main_cli(
    ctx: typer.Context,
    repo: Optional[str] = typer.Option(None, "--repo", "-r", help="Repository name (e.g., 'my-project') or Git URL to process."),
    config_file: Path = typer.Option(
        Path(".config.yml"), # Default Path object
        "--config", "-c",
        help="Path to the configuration file.",
        exists=True, # Typer checks if file exists
        file_okay=True,
        dir_okay=False,
        readable=True,
        resolve_path=True, # Resolve to absolute path
    ),
    version: bool = typer.Option(False, "--version", "-v", help="Show application version and exit.", is_eager=True), # Eager: runs before other processing
    # Debug flag - could be used to set log level later
    debug: bool = typer.Option(False, "--debug", "-d", help="Enable debug mode (more verbose logging).")
):
    """
    Agentic Swarm CLI Entry Point.

    Processes a target repository based on the provided configuration.
    If no command is specified, requires the --repo option to run.
    """
    if version:
        # TODO: Replace with actual version fetching (e.g., from __version__ variable or package metadata)
        typer.echo("Agentic Swarm version: 1.0.0")
        raise typer.Exit()

    # Store context parameters if needed by subcommands or the run callback
    ctx.ensure_object(dict)
    ctx.obj["DEBUG"] = debug
    ctx.obj["CONFIG_FILE"] = config_file
    # Potentially load config here if needed globally, or pass path down

    # If a subcommand (like 'clear') is invoked, let it run.
    # If no subcommand is invoked, we expect to run the main process.
    if ctx.invoked_subcommand is None:
        if repo:
            # Print banner only when running the main process
            banner()
            if _run_callback is not None:
                logger.info(f"Starting main process for repo: {repo}")
                # Pass relevant arguments to the callback
                # Use keyword arguments for clarity and flexibility
                _run_callback(
                    repo=repo,
                    config_file=str(config_file), # Pass path as string if callback expects it
                    debug=debug,
                    # Add other relevant params from main_cli if needed
                )
            else:
                logger.error("Run callback not registered. Cannot start main process.")
                typer.echo("Error: Main application logic not configured.", err=True)
                raise typer.Exit(code=1)
        else:
            # No subcommand and no --repo provided, show help.
            # Typer's default behavior with no_args_is_help=True handles this,
            # but we can be explicit or add a custom message.
            typer.echo("Error: Missing option '--repo' / '-r'.", err=True)
            typer.echo(ctx.get_help()) # Show help context
            raise typer.Exit(code=1)
    # else: Subcommand was invoked, Typer handles calling it.


# --- Clear Commands ---

# Create a sub-Typer app for the 'clear' commands
clear_app = typer.Typer(help="Commands to clear various stored data.", no_args_is_help=True)
# Add the clear_app to the main app under the name 'clear'
app.add_typer(clear_app, name="clear")

def _clear_directory_contents(dir_path: Path, dir_description: str):
    """
    Helper function to delete all files and subdirectories within a directory.
    Logs actions and errors.
    """
    if not dir_path.is_dir():
         logger.warning(f"Directory '{dir_description}' ({dir_path}) not found for clearing. Skipping.")
         print(f"Directory '{dir_description}' not found: {dir_path}")
         return False # Indicate directory wasn't found

    logger.info(f"Clearing contents of '{dir_description}' directory: '{dir_path}'")
    print(f"Clearing contents of {dir_description}: {dir_path} ...")
    cleared_count = 0
    error_count = 0
    for child in dir_path.iterdir():
        try:
            if child.is_file() or child.is_symlink():
                child.unlink()
                logger.debug(f"Deleted file/link: {child}")
                cleared_count += 1
            elif child.is_dir():
                shutil.rmtree(child)
                logger.debug(f"Deleted directory: {child}")
                cleared_count += 1
        except Exception as e:
            logger.error(f"Failed to remove {child.name} from {dir_path}: {e}")
            print(f"  Error removing {child.name}: {e}", file=sys.stderr)
            error_count += 1

    if error_count > 0:
        logger.warning(f"Finished clearing '{dir_description}', but encountered {error_count} errors.")
        print(f"Finished clearing {dir_description} with {error_count} errors.")
    elif cleared_count == 0:
        logger.info(f"Directory '{dir_description}' ({dir_path}) was already empty.")
        print(f"Directory '{dir_description}' was empty.")
    else:
        logger.info(f"Successfully cleared {cleared_count} items from '{dir_description}' ({dir_path}).")
        print(f"Successfully cleared {cleared_count} items from {dir_description}.")
    return True # Indicate clearing was attempted

@clear_app.command("state")
def clear_state():
    """Clears the application state directory."""
    logger.info("Executing 'clear state' command.")
    _clear_directory_contents(STATE_DIR, "state")

@clear_app.command("logs")
def clear_logs():
    """Clears all log files in the logs directory."""
    logger.info("Executing 'clear logs' command.")
    _clear_directory_contents(LOGS_DIR, "logs")

@clear_app.command("thoughts")
def clear_thoughts():
    """Clears stored thoughts from the thoughts directory."""
    logger.info("Executing 'clear thoughts' command.")
    _clear_directory_contents(THOUGHTS_DIR, "thoughts")

@clear_app.command("requests")
def clear_requests():
    """Clears stored requests from the requests directory."""
    logger.info("Executing 'clear requests' command.")
    _clear_directory_contents(REQUESTS_DIR, "requests")

@clear_app.command("repos")
def clear_repos():
    """Clears stored repositories from the repos directory."""
    logger.info("Executing 'clear repos' command.")
    _clear_directory_contents(REPOS_DIR, "repositories")

@clear_app.command("all-but-repos")
def clear_all_but_repos():
     """Clears state, logs, thoughts, and requests, leaving repositories intact."""
     logger.info("Executing 'clear all-but-repos' command.")
     print("Clearing all data except repositories...")
     clear_state()
     clear_logs()
     clear_thoughts()
     clear_requests()
     logger.info("Cleared state, logs, thoughts, and requests.")
     print("Finished clearing data (excluding repositories).")

@clear_app.command("all")
def clear_all():
    """
    Clears ALL stored data: state, logs, thoughts, requests, AND repositories.
    Use with caution!
    """
    logger.warning("Executing 'clear all' command. This will remove repositories.")
    print("Clearing ALL data including repositories...")
    # Ask for confirmation?
    # confirm = typer.confirm("Are you sure you want to delete ALL data, including cloned repositories?", abort=True)
    # If confirmed:
    clear_state()
    clear_logs()
    clear_thoughts()
    clear_requests()
    clear_repos() # Include clearing repos
    logger.info("Cleared state, logs, thoughts, requests, and repositories.")
    print("Finished clearing ALL data.")


# --- Main execution guard ---
if __name__ == "__main__":
    # This makes the Typer app runnable directly
    # In a real application, you'd typically import `app` and potentially
    # register the callback before calling app() from your main script.
    print("CLI module running directly. Registering dummy run callback.")

    # Define a dummy callback for direct execution testing
    def dummy_run_callback(**kwargs):
        print("Dummy run callback invoked with:")
        for key, value in kwargs.items():
            print(f"  {key}: {value}")
        # Simulate some work
        interactive_pause(1)
        interactive_pause(2)
        print("Dummy run finished.")

    register_run_callback(dummy_run_callback)

    # Call the Typer application
    app()
